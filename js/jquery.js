/ *! jQuery v@1.8.1 jquery.com | jquery.org licencia / * /
(Function (a, b) {function G (a) {var b = F [a] = {}; retorno p.each (a.split (s), función (a, c) {b [c] =! 0}), b} function J (a, c, d) {if (d === b && a.nodeType === 1) {var e = "data" + c.replace (I, "- $ 1") . toLowerCase (); a.getAttribute d = (e); if (typeof d = b} return d} function K (a) {var b; para (b en a) {if (b === "datos" && p.isEmptyObject (a [b])) continuar; if (b! == "toJSON") return 1} return 0} ba function () {return 1} function bb () {return 0} function bh (a) {return a |!! |! a.parentNode | | a.parentNode . nodeType 11} === función bi (a, b) {hacer a = a [b], mientras que (a && a.nodeType == 1!), y devuelve una función bj} (a, b, c) {b = b | | 0, si (p.isFunction (b)) return p.grep (una función, (a, d) {var e = b.call (a, d, a); retorno e === c!} ), si (b.nodeType) return p.grep (una función, (a, d) {return a === === b c}); if (b == typeof "string") {var d = p . grep (una, function (a) {return a.nodeType === 1}); if (be.test (b)) return p.filter (b, d, c!), b = p.filter (b , d)} retorno p.grep (una función, (a, d) {return p.inArray (a, b)> = 0 === c})} function bk (a) {var c} function aC (a, b) {a.getElementsByTagName retorno (b) [0] | | a.appendChild (a.ownerDocument.createElement (b))} function BD (a, b) {if (b.nodeType! == 1 | | p.hasData (a)) return;! var c, d, e, f = p._data (a), g = p._data (b, f), h = f.events; if ( h) {delete g.handle, g.events = {}; para (c en ser (a, b) {var bF (a) {return a.getElementsByTagName typeof = "undefined" a.getElementsByTagName ("*"):? a.querySelectorAll typeof = "undefined" a.querySelectorAll ("*"):? []} function BG ( a) {bv.test a.type () && (a.defaultChecked = a.checked)} function por (a, b) {if (b en un ida y vuelta) b;. var c = b.charAt (0) toUpperCase () + b.slice (1), d = b, e bW.length =, mientras que (e -) {b = BW [e] + c; si (b en a) retorno b} retorno d} función bZ (a, b) {return a = b | | a, p.css (a, "display") === "ninguno" | |! p.contains (a.ownerDocument, a)} function b $ (a, b) {var una función} b_ (a, b, c) {var d = bP.exec (b);? retorno d Math.max (0, d [1] - (c | | 0)) + (d [2] | | "px"): b} función ca (a, b, c, d) {var f} function cb (a, b, c) {var d; E = f && (p.support.boxSizingReliable | | d === a.style [b]), d = parseFloat (d) | | 0} retorno d + ca (a, b, c | | (f? "frontera": "contenido"), e) + "px"} cc función () {if (bS [a]) return bS [a]; var BS [a] = c, c} ci función (a, b, c, d) {var e; si (p.isArray (b)) p.each (b, la función (b, e) {c | | ce . prueba (a) d (a, e): ci (a + "[" + (e == typeof "objeto" b: "") + "?]", e, c, d)}); else if? para (e en b) ci (a + "[" + e + "]", b [e], c, d) (c && p.type (b) === "objeto"!); más d (a, b) } function cz (a) {function return (b, c) {b typeof = "cadena" && (c = b, b = "*");! var cA (a, c, d, e, f, g) {f = f | | c.dataTypes [0], g = g | | {}, g [f] = 0;! var h, i = a [ ? f], j = 0, k = i i.length: 0, l = a === cv; for (;! j <k && (l | | h), j + +) h = i [j] (c, d, e), typeof cB (a, c) {var d, e, f = p.ajaxSettings.flatOptions | | {}; para (d de c) c [d] == b && ((f [d] a:? e | | (e = {})) [d] = c [d]);! e && CC p.extend (0, a, e)} function (a, c, d) {var e, f, g, h, i = a.contents, j = a.dataTypes, k = a.responseFields, porque (f en k) f en en i) si (i [f] && i [f] test (p.)) {j.unshift (f); break} if (j [0] d) g = j [0]; else {para (f en la letra d) {if (j [0] | | a.converters [f + "" + j [0]]) {g = f;! break} h | | (h = f)} g = g | | h} if (g) g regresar! == j [0] && j.unshift (g), d [g]} function cD (a, b) {var en "+ E] | | i [" * "+ e], y si para (i d a) {f = d.split (c!) (" "); If (f [1] === e) {c i = [h + "" + f [0]] | | i ["* try {b = c (b)} catch (k) {return {estado: "ParserError", error: c K: "Ninguna conversión de" + h + "a" + e}}} h = e} return {estado : el "éxito", los datos: b}} function cL () {try {return new a.XMLHttpRequest} catch (b) {}} function cm () {try {return new a.ActiveXObject ("Microsoft.XMLHTTP")} catch (b) {}} function cU () {setTimeout retorno (function () {cn} = b, 0), CN = p.now ()} function cV (a, b) {p.each (b, la función (b, c) {var d = (cT [b] | | []) concat (cT ["*"]), e = 0, f = d.length;. for (; e <f, e + +) si (d [e]. llamada (a, b, c)) return})} la función CW (a, b, c) {var d, e = 0, f = 0, g = cS.length, h = p. Diferido (). siempre (function () {delete} i.elem), i = function () {var e = p.Tween (a, j.opts, b, c, j.opts.specialEasing [b] | | j.opts.easing); j.tweens.push retorno (e), e}, parada: función ( b) {var c = 0, d = b j.tweens.length:. 0; for (; c <d, c + +) j.tweens [c] run (1); retorno d} return cX (a, b) {var c, d, e, f, g; para (c en a) {d = p.camelCase (c), e = b [d], f = a [c], p. IsArray (f) && (e = f [1], f = a [c] = F [0]), c! == d && (a [d] = f, eliminar un [c]), g = p. cssHooks [d]; if (g && "expandir" en g) {f = g.expand (f), eliminar un [d], porque (en c f) c en a | | (a [c] = f [c ], b [c] = e)} else b [d] = e}} función cY (a, b, c) {var b | | "ancho" en en b) {f = b [d] if (cP.exec (f)) {delete b; p.removeData (a, "fxshow", 0!); para (b en n) p.style (a, b, n [b])}); para (d = 0; d <g; d + +) e = o [d], i = l.createTween (e, q h [e]:? 0), n [e] = h [e] | | p.style (a, e), h en e | | (h [e] = i.start, && q (= i.end i.start, i.start === = e "ancho" | |? === e "altura" 1:0))}} function cZ (a, b, c, d, e) {return nuevo cZ.prototype.init (a, b, c, d, e)} function c $ (a, b) {var c, d = {altura: a} , e = 0, b = b 01:00;? for (; e <4; e + = 2-b) c = BV [e], d ["margen" + c] = d ["relleno" + c] = a; retorno b && (d.opacity = d.width = a), d} function da (a) {return p.isWindow (a) a: === a.nodeType 9 a.defaultView | | a?. parentWindow: 1} var nuevo f, g, h, i, (! a) si devolver este; if (a.nodeType) return = this.context este [0] = a, this.length = 1, esto; if (typeof c = c instanceof d.find (a); this.length = 1, este [0] = g} return this.length}, toArray: function () {k.call regreso (this)}, obtener: function (a) {return un this.toArray == null ():? a <0 este this.length [+ un ]: este [a]}, pushStack: function (a, b, c) {var d = p.merge (this.constructor (), a); retorno d.prevObject = esto, d.context = this.context, b === "encontrar" d.selector this.selector = + (this.selector "?": "")? + c: "." b && (d.selector this.selector = + + b + "(" + c + ") "), d}, cada uno: función (a, b) {p.each retorno (esto, a, b)}, listo:. función (a) {p.ready.promise retorno () realiza (a), esta }, eq: function (a) {return a = + a, a === -1 this.slice (a):? this.slice (a, a +1)}, en primer lugar: function () {return esto. EQ (0)}, el pasado: function () {return this.eq (-1)}, rebanada: function () {this.pushStack retorno (k.apply (esto, argumentos), "rebanada", k.call ( argumentos.) join (","))}, el mapa: function (a) {this.pushStack retorno (p.map (this, function (b, c) {return a.call (b, c, b)}) )}, final: function () {return a, c, d, e, f, g, h = arguments [0] | | {}, i = 1, j = arguments.length, k = 1, h == typeof "booleano" && (k = h! , h = arguments [1] | | {}, i = 2), typeof en h}, p.extend ({noConflict: function (b) {return p.type (a) === "función"}, isArray: Array.isArray | | función () {return p.type (a) === "array"}, IsWindow: function (a) {return d; para (d en a); retorno d === b | | n.call (a, d)}, isEmptyObject:! función (a) {var b; para (b en a) return 1; retorno 0 }, error: function (a) {throw new Error (a)}, ParseHTML: function (a, b, c) {var d, retorno a | | un typeof = "cadena" null:? (typeof b = "cadena") return null;! b = p.trim (b), si (a.JSON a.JSON.parse &&) a.JSON.parse retorno (b), si (w.test (b.replace (y ., "@") reemplazar (z, "]") sustituir (x, ""))) return (new Function ("return" + b)) (); p.error ("Invalid JSON:." + b )}, parseXML: function (c) {var d, e; if (c | | c typeof = "cadena") return null; try {a.DOMParser (e = DOMParser nuevo, d = e.parseFromString (¡!? c, "text / xml")): (d = new XML: a.replace (A, "ms-") reemplazar (B, C)}, nodeName:. función (a, b) {return a.nodeName a.nodeName.toUpperCase && () === b.toUpperCase ()}, cada : función (a, c, d) {var e, f = 0, g = a.length, h = g === b | | p.isFunction (a), si (d) {if (h) {for (e en a) if (! c.apply (a [e], d) === 1) romper} else for (; f <g ;) if (c.apply (a [f + +], d) == ! = 1) romper} else if (h) {for (e en a) si (c.call (a [e], e, a, [e]) === 1) romper} else for (;! f < g ;) si romper, volver a}, trim (c.call (a [f], f, a [f + +]) === 1!): Función && o o.call ("ï» ¿") (? a) {return a == null "?": o.call (a)}: function (a) {return a == null? "":. a.toString () reemplazar (t, "")}, MakeArray : function (a, b) {var c, d = b | | []; retorno d; if (b) {if (l) return l.call (b, a, c), d = b.length, c = c c <0 Math.max (0, d + c):? c: 0; for (; c <d, c + +) if (c en b && b [c] === a) la devolución c} return-1}, la función de combinación: (a, c) {var d = c.length, e = a.length, f = 0; if (typeof d == "número") for (; f <d, f + +) a [e + +] = c [f]; otro while (! c [f] == b) una [e + +] = c [f + +]; a.length retorno = e, a}, grep: función (a, b, c) {var d, e = [], f = 0, g = a.length; c = ! c; for (; f <g, f + +) d = b (a [f], f), c == d && e.push (a [f]), e return}, el mapa: ¡¡¡la función (un , c, d) {var e, f, g = [], h = 0, i, j = a.length = a instanceof p | | i! == b && typeof para (f en a) e = c (a [f], f, d), e = && nulos (g [g.length] = e);! g.concat.apply regreso ([], g)}, guid : 1, proxy: función (a, c) {var d, e, f; retorno typeof c == "cadena" && (d = a [c], c = a, a = d), p.isFunction (a )? (e = k.call (argumentos, 2), f = function () {return i, j = d == null, k = 0, l = a.length; if (typeof d && d == "objeto") {for (k in d) p.access (a, c, k, d [k] , 1, g, e), f = 1} else if (E! == b) {i = h === b && p.isFunction (e), j && (i (i = c, c = function (a,? b, c) {return f a: j c.call (a):? l c (a [0], d): g}, ahora: function () {return (nuevo ! c = 1; try {c = a.frameElement == NULL && e.documentElement} catch (f) {} && c c.doScroll && función g () {if {try {c.doScroll ("izquierda")} (p.isReady!) catch (a) {return división setTimeout (g, 50)} p.ready ()}} ()}} return d.promise (b)}, p.each ("String Boolean Número de función array Fecha RegExp objeto". ( ""), la función (a, b) {E ["[objeto" + b + "]"] = b.toLowerCase ()}), c = p (e); var F = {}; p.Callbacks = function (a) {a = a == typeof "cadena" F [a] | | G (a):? p.extend ({}, a); var b = i.length; (función d (b) {p.each (b, la función (b, c) {var esto}, remove: function () {return i && p.each (argumentos, la función (a, b) {var p.inArray (a, i)> -1}, vacío: function () {return i = [], esto}, deshabilitar: return function () {i = j = c = b, esto}, discapacitados: function ( ) {return i!}, bloqueo: function () {return j = b, c | | l.disable (), esto}, bloqueado: function () {!} j retorno, fireWith: function (a, b) { regresar b = b | | [], b = [a, b.slice b.slice (): b?], i && | && (e j.push (b) (d | j!): k (b)? ), esto}, el fuego: function () {return l.fireWith (esto, argumentos), esto}, disparó:! function () {return d}};} l retorno, p.extend ({diferido: function ( a) {var b = [["resolver", "hacer", p.Callbacks ("memoria una vez"), "resuelto"], ["rechazar", "no", p.Callbacks ("una vez c}, siempre: function () {return e.done (argumentos) no (argumentos), esto}, entonces: function () {var a = argumentos; volver p.Deferred (function (c) {p.each (. b, la función (b, d) {var f = d [0], g = a [b];? e [d [1]] (p.isFunction (g) function () {var a == typeof "objeto" p.extend (a, d): d}}, e = {}; retorno d.pipe = d.then, p.each (b, la función (a, f) {var Array (d), i = new Array (d), j = new e | | f.resolveWith (j, c), f.promise ()}}), p.support = función () {var b, c, d, f, g, h, i, j, k, l, m, n = e.createElement ("div"); n.setAttribute ("className", "t"), n.innerHTML = "<link/> <table> </ table> <a href = '/ a' > a </ a> <input en {presentar: 0, cambie: 0, focusIn:! 0}) j = "on" + k, l = j en n, l | | (n.setAttribute (j, "return;"), l = typeof n [j] == "función"), b [k + "Burbujas"] = l, p regreso (function () {var f, g, h = p.expando, i = typeof c == 'objeto' | | c == typeof "función") e k [l] = p.extend (k [l], c):. k [l] data = p.extend (k [l] . datos, c); retorno en d b = [b]: (b = p.camelCase (b), b en d b = [b]: b = b.split ("")?)); para (e = 0, f = b? . longitud, e <f, e + +) delete d [b [e]], si: (d)) return}} if (c) {delete H [i] Datos ((c K p.isEmptyObject?)!. y si regreso} g p.cleanData (K (h [i])!)? ([a], 0!):? p.support.deleteExpando | | h = h h.window delete [i]: h [ i] = null}, _data: función (a, b, c) {return p.data (a, b, c, 0!)}, acceptData: function (a) {var k} return typeof this.each (function () {p.removeData (esto, a)})}}), p.extend ({cola: function (a, b, c) {var d, si: (a) la devolución f.stop, e.call (a, g, f)), d && f && f.empty.fire ()}, _queueHooks: function (a, b) {var c = b + "queueHooks"; p._data retorno (a,! c) | | p._data (a, c, {empty: p.Callbacks ("una vez d = 2; retorno typeof this.each (function () {p.dequeue (esto, a)})}, retraso: function (a, b) {return a = p.fx p.fx.speeds [a] | | R: A, b = b | | "fx", this.queue (b, la función (b, c) {var d = setTimeout (b, a); c.stop = function () {clearTimeout (d)}})}, clearQueue : function (a) {return this.queue (a | | "fx", [])}, Promesa: function (a, c) {var d, e = 1, f = p.Deferred (), g = este, h = this.length, i = function () {- e | | f.resolveWith (g, [g])}; typeof i (), f.promise (c)}}); var p.access (esto, p.attr, a, b, arguments.length> 1)}, removeAttr: function (a) {return this.each (function () {p.removeAttr (esto, a)})}, prop: función (a, b) {p.access retorno (esto, p.prop, a, b, arguments.length> 1)}, removeProp: function (a) {return a = p.propFix [a] | | a, this.each (function () {try {este [a] = b, eliminar este [a]} catch (c) {}})}, addClass: function (a) {var b, c, d, e , f, g, h, si (p.isFunction (a)) return this.each (function (b) {p (este) addClass (a.call (esto, b, this.className)).}), y si (a typeof && "+ + E.className" "; para (g = 0, h = b.length; g <h; g+ +) ~ f.indexOf (" "+ b [g] +" ") | | (f + b = [g ] + ""); e.className = p.trim (f)}}}} devolver este, removeClass: function (a) {var c, d, e, f, g, h, i, si (p.isFunction (a)) retorno this.each (función de (b)) {p (este) removeClass (a.call (este, b, this.className)).}; si (a typeof && "+ E.className +" ") reemplazar (O,". "), Porque (f = 0, g = c.length, f <g, f + +) while (d.indexOf (" "+ c [f] +" ")> -1) d = d.replace (" "+ c [f] +" "," "); e.className = a p.trim (d):" "}}}} devolver este, toggleClass : function (a, b) {var c = typeof a, d = b == typeof "booleano"; retorno b = "" + a + "", c = 0, d = this.length; for (; c <d, c + +) if (esto [c] nodeType === 1 && ("" + este [c] className +.. "") reemplazar (O, ".") indexOf (b)> -1) return 0;} return 1, val.! función () {var c, d, e, f = presente [0]; si {if (f) return c = p.valHooks [f.type] (arguments.length!) | | p.valHooks [f.nodeName.toLowerCase ()], c && "get" en && c (d = c.get (f, "valor")) == b d:? (d = f.value, typeof d == "string" d.replace (P, "?"): d == null "": d) ;} return retorno e = p.isFunction (a), this.each (function (d) {var f, g = p (this); if (this.nodeType == 1) return;! e f = a?. llamar (este, d, g.val ()): f = a, f == null f = "": == typeof f "número"? f + = "": p.isArray (f) && (f = p.map (f, function (a) {return un nulo == "": a + "?"})), c = p.valHooks [this.type] | | p.valHooks [this.nodeName.toLowerCase () ], (! c | | ("set" en c) | | c.set (esto, f, "valor") === b) si this.value = f})}}), p.extend ( {valHooks: {opción: {get: function (a) {var b = a.attributes.value, retorno b | | b.specified a.value:? a.text}}, seleccione: {get: function (un ) {var b, c, d, e, f = a.selectedIndex, g = [], h = a.options, i = a.type === "select-uno"; if (f <0) retorno b; g.push (b)}} return i && g.length h.length && p (h [f]) ​​val (): g}, establece: function (a, b) {var c = p.makeArray (¡?. b) volver f, g, h, i = a.nodeType; (! a | | i === 3 | | i === 8 | | i === 2) si a cambio; if (&& e p.isFunction (P. Fn [ c])) return p (a) [c] (d); if (typeof a.getAttribute == "undefined") return && g "ajuste" en && g h && (f = g.set (a, d, c)) == b f:? (a.setAttribute (c, "" + d), d)} return && g "get" en && g h && (f = g.get (a, c)) == NULL f:? (f = a.getAttribute (c), f === nulo b:? f)}, removeAttr: función (a, b) { var en unos && (a [c] = 1!))}}, attrHooks: {type: {set: function (a, b) {if ((Q.test a.nodeName) && a.parentNode) p.error ("tipo propiedad no se puede cambiar "); else if (p.support.radioValue && b ===!" radio "p.nodeName && (a," entrada ")) {var c = a.value; a.setAttribute retorno (" tipo ", b), c && (a.value = c), b}}}, valor: {get: function (a, b) {L retorno && p.nodeName (a," ¿button ") L.get (a, b ): b en un a.value: nulo}, set: function (a, b, c) {if (L p.nodeName && (a, "button")) return e, f, g, h = a.nodeType, si regreso (a | | h === 3 | | | h === 8 | h === 2!);! devolución g = h == 1 | | ! p.isXMLDoc (a), && g (c = p.propFix [c] | | c, f = p.propHooks [c])?, d == b && f "ajuste" en f && (e = f.set (a, d, c)) == b electrónico: ¿un [c] = d: f && "get" en f && (e = f.get (a, c)) == null electrónico: ¿un [c ]}, propHooks: {tabIndex: {get: function (a) {var c = a.getAttributeNode ("tabindex"); retorno d, e = p.prop (a, c);!? Regresar === 0 | | typeof e = "booleano" && (d = a.getAttributeNode (c)) && c == 1 d.nodeValue . toLowerCase (): b}, set: function (a, b, c) {var d, b regreso === 1 p.removeAttr (a, c):? (d = p.propFix [c] | | c, d en d; volver d = a.getAttributeNode (c), d && (N [c] d.value == "": d.specified?) d.value: b}, set: function (a, b, c)? {var d = a.getAttributeNode (c); retorno ? d = a.getAttribute (c, 2), d vuelta === nulo b: d}})}), p.support.style | | (p.attrHooks.style = {get: function (a) {return a.style.cssText.toLowerCase () | | b}, set: function (a, b) {return b a.parentNode =; retorno a.checked p.inArray = (p (a) val (), b.)> = 0}})}); var p.event.special.hover a: a.replace (X, "MouseEnter MouseLeave $ 1 $ 1")}; p.event = {add: función (a, c, d, e, f) {var typeof "), Porque (f = 0; f <b.length, f + +) {g = W.exec (b [f]) ​​| | [], h = i = g [1], j = g [2]; if (! h) {for (h en m [h])} p.isEmptyObject (m) && (borrar c == "objeto" c [p.expando] c:? nuevo p.Event (s, c): nuevo en s.postDispatch && s.postDispatch.call (esto, c), c.result}, utilería: "attrChange attrName relatedNode srcElemento altKey burbujas currentTarget cancelable ctrlKey eventPhase metaKey relatedTarget shiftKey vista objetivo timeStamp que" split (""), fixHooks:. {} , keyHooks: {utilería: "char keyCode charCode clave" split (""), el filtro:. función (a, b) {return a.which == NULL && (a.which = b.charCode = null b.charCode? : b.keyCode), a}}, mouseHooks: {utilería: "buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX toElement screenY" split (""), el filtro:. función (a, c) {var d, f, g, h = c.button, i = c.fromElement, retorno A; var e = p.extend (nuevo d = "on" + b; a.detachEvent && (typeof a [d] == "undefined" && (a [d] = null), a.detachEvent (d, c))}, p.Event = function (un , b) {if (esta instanceof return new p.Event (a, b)} = {p.Event.prototype preventDefault: function () {this.isDefaultPrevented = bb, var keypress._submit ", function (a) {var b = a.target; if (! this! == b | | a.isSimulated | | a.isTrigger | | b.type == "radio" b.type && == "checkbox") return a.handleObj.handler . aplicar (esto, argumentos)}, desmontaje: function () {return g, h; if (a == typeof "objeto") {c typeof = "cadena" && (d = d | | c, c = b);! de (h a) this.on (h, c, d, a [h], f);} devolver esta d == NULL && e == null (e = c, d = c = b):? E == NULL && (typeof c == "string" (e = d , d = b): (e = d, d = c, c = b)); if (e === 1) e = ba; else if (e) devolver este; retorno f === 1 && (! g = e, e = función (a) {return this.on (a, b, c, d, 1)}, fuera: función (a, c, d) {var e, f, si (a && a.preventDefault a.handleObj &&) retorno a == "object") {for (f en a) this.off (f, c, a [f]);} devolver este if (c === 1 | | c == typeof "función") d ! = c, c = b; retorno d === 1 && (d = BA), this.each (function () {p.event.remove (esto, a, d, c)})}, se unen: function ( a, b, c) {this.on retorno (a, null, b, c)}, unbind: función (a, b) {return this.off (a, null, b)}, en vivo: función (a, b, c) {return p (this.context) en (a, this.selector, b, c), esta.}, troquel: función (a, b) {return p (this.context) off (a,. this.selector | | "**", b), esto}, delegado: función (a, b, c, d) {return this.on (b, a, c, d)}, undelegate: función (a, b, c) {arguments.length retorno == 1 this.off (a, "**"):? this.off (b, a | | "**", c)}, el gatillo: función (a, b, ) {return this.each (function () {p.event.trigger (a, b, este)})}, triggerHandler: function (a, b) {if (esta p.event.trigger [0]) return ( ! a, b, este [0], 0)}, toggle: function (a) {var b = argumentos, c = a.guid | | p.guid + +, d = 0, e = function (c) {var e = (p._data (this, "lastToggle" + a.guid) | | 0)% d; retorno this.click (e)}, hover: function (a, b) {this.mouseenter retorno (a) mouseleave (b | | a)}}), p.each ("blur foco focusIn cambio de tamaño de carga focusOut scroll descargar haga clic. DblClick mousedown mouseup mousemove mouseover mouseout MouseEnter cambio mouseleave seleccione Enviar keydown pulsación de tecla contextual error keyup ". split (" "), la función (a, b) {P.Fn [b] = function (a, c) {return $ (A, b, c, d) {c = c | | [], b = b | | q;! Var e, f, g, j, k = b.nodeType; si (k! == 1 && k = = 9) return [];! if (a | | un typeof = "cadena") return c; if (f.id === j) return c.push (f), c} else if (&& b.ownerDocument (F = b.ownerDocument.getElementById (j)) && i (b, f) && = f.id == j) return c.push (f), c} else {if (e [2]) return u.apply (c, T.CALL (b.getElementsByTagName (a), 0)), c; if (( j = E [3]) && X) && b.getElementsByClassName retorno u.apply (c, T.CALL (b.getElementsByClassName (j), 0)), c} return bk (a, b, c, d, g)} function _ (a) {return función (b) {var c = b.nodeName.toLowerCase (); c === retorno de "entrada" && b.type === a}} function ba (a) {function return (b) {var c = b.nodeName.toLowerCase (); return (c === "entrada" | | C === "botón") && b.type === a}} function bb (a, b, c) { if (a === b) return c; var d = a.nextSibling, mientras que (d) {if (d === b) return-1, d = d.nextSibling} return 1} function bc (a, b , c, d) {var e, g, h, i, j, k, l, m, n, p, r = c && b == q, s = (r "<S>":!? "") + a.replace (H, "<S> $ 1"), u = y [o] [s]; if (u) return "+ J); e = 1;!. Si (g = J.exec (j)) = l + g [0], j = j.slice (g [0] de longitud), e = h.push ({parte : g.pop () reemplazar (H, ""), cadena: g [0], capturas:. g}); for (i in && l (h.selector = l), d j.length:? J $ de error (a):?. T.CALL (y (s, k), 0)} function bd (a, b, e, f) { var g = b.dir, h = s + +; regreso a | | (a = function (a) {return a === e}), b.first función (b) {while (b = b [g])? if (b.nodeType === 1) volver a (b) && b}: f (b) {while (b = b [g]) if (b.nodeType === 1 && a (b)) return b} : function (b) {var e, f = h + + c, i = f + + d, mientras que (b = b [g]) if (b.nodeType === 1) {if (("." "". e = b [o]) === i) b.sizset retorno; if (typeof e == "cadena" && e.indexOf (f) === 0) {if (b.sizset) return b} else {b [o] = i; if (a (b)) return b.sizset = 0, b;! b.sizset = 1}}}} function ser (a, b) {return una función (c) {var? d = b (c); retorno d && una (d === 0 c:? d)}: b} función bf (a, b, c) {var e} function bg (a) {function return (b) {var c, d = 0; for (; c = a [d], d + +) if (c (b)) return 0;! return 1}} function bh (a, b, c, d) {var e = 0, f = b.length; for (; e <f; e + +) $ (a, b [e], c, d)} función bi (a, b, c, d, e, g) {var h, i = f.setFilters [b.toLowerCase ()];.! devolución i | | $ error (b), (a | | (h = e)) && bh (a | | "*", d, h = [], e), h.length> 0 i (h, c, g):? []} bj función (a, c, d, e) {var f , g, h, i, j, k, l, m, n, o, p, q, r, s = 0, t = a.length, v = S.POS, w = new RegExp ("^" + v.source + "(?!" A + + ")", "i"), x = function () {var ?. t === 1 d: $ UNIQUESORT (d)} function bk (a, b, e, g, h) {a = a.replace (H, "$ 1"); var i, k, l, m , n, o, p, q, r, s, v = bc (a, b, h), w = b.nodeType; si (S.POS.test (a)) retorno bj (v, b, e, g); if (g) i = T.CALL (g, 0); más e} var a [o] = b | | 0, a}, w = function () {var a = {}, b = [];! retorno v (function (c, d) {return b.push (c)> f cacheLength borrar. && RegExp ("^" + A + "+ | ((: ^ | [^ \ \ \ \]) (:?. \ \ \ \) *)" + A + "+ $", "g"), I = nuevo RegExp ("^" + A + "*" + A + "*"), J = new RegExp ("^" + A + "* ([\ \ x20 \ \ t \ \ r \ \ n \ \ f> + ~]) "+ A +" * "), K = new RegExp ("^ # (" + B + ")"), CLASE: new RegExp ("^ \ \ (." + B + ")"), NOMBRE: new RegExp ("^ \ \ [nombre = ['\"] ? ("+ B +") ['\ "] \ \]?"), TAG: new RegExp ("^ (" + B.replace ("w", "w *") + ")"), ATTR: nuevo RegExp ("^" + E), PSEUDO: new RegExp ("^" + F), INFANTIL: nuevo RegExp (G, "ig"), needsContext: new RegExp ("^" + A + "* [> + ~] |" + G, "i")}, T = function (a) {var b = q.createElement ("div"); try {volver a (b)} catch (c) {return 1!} finally {b = null}}, U = T (function (a) {a.appendChild retorno (q.createComment (" ")),! a.getElementsByTagName (" * ").} longitud), V = T (function (a) {return a.innerHTML =" <a href='#'> </ a> ", a.firstChild && typeof b = typeof a.lastChild.getAttribute ("múltiple");! retorno b == "booleanas" && b == "string"}), X = T (function (a) {return a.innerHTML = "<div class = 'oculto e'> </ div> <div name = '"+ o +"'> </ a> <div name='"+o+"'> </ div> ", r.insertBefore (a, r.firstChild); var b = && q.getElementsByName q.getElementsByName ( .. o) === longitud 2 + q.getElementsByName (o 0) de largo retorno b, c = []; for (; b = esto [a], un + +) c.push (b). regresar c}} $ coincidencias = function (a, b) {return $ (a, null, null, b)} $. matchesSelector = function (a, b) {return $ (a, null, null, [a]). longitud> 0}, g = $. getText = function (a) {var b, c = "", d = 0, e = a.nodeType; if (e) {if (e === 1 | | e === 9 | | e === 11) {if (typeof a.textContent == " cadena ") a.textContent retorno; para (a a.firstChild =; a; a = a.nextSibling) c + = g (a)} else if (e === 3 | | e === 4) volver a. nodeValue} else for (; b = a [d], d + +) c + = g (b); retorno c}, h = $ isXML = function (a) {var b = a && (a.ownerDocument | | a).. documentElement b regreso b.nodeName == "HTML":?!.? 1}, i = $ contiene r.contains = función (a, b) {var c = a.nodeType === 9 a.documentElement :! a, d = b && b.parentNode, retorno a === D | | (d && d. NodeType === 1 && && c.contains c.contains (d))}:? r.compareDocumentPosition función (a, b) {return c, d = h (a); retorno RegExp ("ID | TAG" + (Y "| NOMBRE": "") + (X? "| CLASE": ""))?, AttrHandle: {V}: {href: function (a) {return un . getAttribute ("href", 2)}, tipo: function (a) {a.getAttribute return ("tipo")}}, encontrar: {ID: función e (a, b, c) {if (typeof b . getElementById! == n && c) {var d = b.getElementById (a); d.parentNode retorno && d [d]: []}}!: function (a, c, d) {if (typeof c.getElementById! == && N d) {var e = c.getElementById (a);!?!. retorno e e.id === a | | typeof valor e.getAttributeNode == n && e.getAttributeNode ("id") === un ¿[e]: b: []}}, TAG: U función (a, b) {if (typeof b.getElementsByTagName == n!) return b.getElementsByTagName (a)}: function (a, b) { var c = b.getElementsByTagName (a), si (a === "*") {var d, e = [], f = 0; for (; d = c [f], f + +) d.nodeType == = 1 && e.push (d);} return retorno e c}, NOMBRE: function (a, b) {if (typeof b.getElementsByName == n!) b.getElementsByName retorno (nombre)}, CLASE: function (a, b, c) {if (typeof b.getElementsByClassName == n && c) la devolución b.getElementsByClassName (a)!}}, relativo: {">": {dir: "parentNode", primero: 0} ", a [1] = a [1] reemplazar (R, ""), a [3] = (a [4] | | a [5] | | "."). replace (R, ""), a [ 2] === "~ =" && (a [3] = "" + a [3] + ""), a.slice (0,4)}, NIÑO: function (a) {return d, e, si (S.CHILD.test (a [0])) return null; si (a) [3] a [2] = a [3]; más a.slice (0,3)}}, filtro: {ID: función e (a) {return "un b.getAttribute retorno, función (b) {= a.replace (R") ("id") a}} ===: function (a) {return a = a.replace (R, ""), la función (b) {var c = typeof b.getAttributeNode == n && b.getAttributeNode! ("id"); retorno c && c.value === a}}, TAG: function (a) {return a === "*" function () {return 0}:?! (a toLowerCase a.replace = (R, "") (. ), la función (b) {return b.nodeName b.nodeName.toLowerCase && () === a})}, CLASE: function (a) {var x = b [o] [a]; retorno b | | (b = x (a, new RegExp ("(^ |" A + + ")" + a + "(" + A + "| $)"))), la función (a) {return b.test (a.className | | typeof un . getAttribute == n a.getAttribute && ("class") | | "")}}, ATTR:?. función (a, b, c) {return función b (d) {var e = $ attr (d, a ), f = e + ""; if (e == null) return b === "="; interruptor (b) {case "=!": return f === c; caso "=": return f ! == c; caso "^ =": retorno && c f.indexOf (c) === 0; caso "* =": return c && f.indexOf (c)> -1; case "$ =": return c && f.substr (f.length-c.length) === c; caso "~ =": return ("" + f + "") indexOf (c)> -1, y el caso "| =":. === retorno f c | | f.substr (0, c.length +1) === c + "-"}}: function (b) {return $ attr (b, a) = null}}, NIÑO: function (a,.! b, c, d) {if (a === "enésima") {var e = s + +; retorno de la función (a) {var f = a.sizset-d, c === 0 === 0 f: f% c === 0 && f / c> = 0}} return función (b) {var e, g = f.pseudos [a] | | f.pseudos [a.toLowerCase ()]; retorno g | | $ error ("pseudo compatibles:" + a)., g [o] g (b, c? , d): g.length> 1 (e = [a, a, "", b], la función (a) {return g (a, 0, e)}):? g}}, pseudos: no {: v (function (a, b, c) {! var d = j (a.replace (H, "$ 1"), b, c), función de retorno (a) {return d (a)}}), habilitada: función () {return a.disabled === 1!}, discapacitados: function (a) {return a.disabled === 0!}, comprobado: function (a) {var b = a.nodeName.toLowerCase ( ); b === retorno de "entrada" && a.checked | | b === "opción" && a.selected}, seleccionados: ¡¡¡! function (a) {return función (b) {return (b.textContent | | b.innerText | | g (b)) indexOf (a)> -1.}}), cuenta con: v (function (a) {function return (b) {return $ (a, b) longitud> 0}}), el encabezado: function (a) {return P.test (a.nodeName)}, text:. función () {var b, c; retorno b = a.nodeName.toLowerCase (); b === retorno de "entrada" && a.type === "botón" | | b === "botón"}, entrada: function (a) {return Q.test ( a.nodeName)}, el foco:! función (! a) {var b = a.ownerDocument; volver a && b.activeElement === (b.hasFocus | | b.hasFocus ()) && (a.type | | ! a.href)}, activo: function (a) {return un a.ownerDocument.activeElement ===}}, setFilters: {primero: función (a, b, c) {return c a.slice (1? ): [a [0]]}, última:? función (a, b, c) {var d = a.pop (); c retorno a: [d]}, incluso: función (a, b, c) {var d = [], e = c 1:0, f = a.length; for (; e <f, e = e +2) d.push (a [e]); retorno d?}, impar: función (a, b, c) {var d = [], e = 0:1 c, f = a.length;? for (; e <f; e = e +2) d.push (a [e] ); retorno d}, LT: función (a, b, c) {return c a.slice (+ b): a.slice (0, + b)}, gt: función (a, b, c) {? retorno a.slice c (0, + b +1): a.slice (+ b +1)}, eq:? función (a, b, c) {var d = a.splice (+ b, 1); c un retorno:? d}}}, k = retorno r.compareDocumentPosition función (a, b) {? l = 0,0;! si (a.sourceIndex && b.sourceIndex) retorno a.sourceIndex-b.sourceIndex; var c, d, e = [], f = [], g = a.parentNode, h = b.parentNode , i = g; if (g === h) return bb (a, b); (! g) si el regreso-1; (! h) si el retorno j = 0; j <c && j <d, j + +) if (e [j] == f [j]) return bb (e [j], f [j]);? devolución j === c bb (un , f [j], -1):.!. bb (e [j], b, 1)}, [0,0] sort (k), m = l, $ UNIQUESORT = function (a) {var b , c = 1; l = m, a.sort (k), si (L) para (b = a [c]; c + +) b === A [C-1] && a.splice (c -, 1); volver a}, $ error = function (a) {throw new Error ("Error de sintaxis, la expresión no reconocido:" + a)}, j = $ compilar = function (a, b, c) {var d.. , e, f, g = z [o] [a]; if (g && g.context === b) la devolución g, d = bc (a, b, c), porque (e = 0, f = d.length , E <F, E + +) d [e] = bf (d [e], b, c), g = retorno Z (A, BG (d)), g.context = b, g.runs = g.dirruns = 0, g}, q.querySelectorAll función && () {var RegExp (e.join ("|")), bk = function (a, d, f, g, h) {if (&& g h && (e |! |! E.test (a))) if (d . nodeType === 9) try {retorno u.apply (f, T.CALL (d.querySelectorAll (a), 0)), f} catch (i) {} else if (d.nodeType === 1 && d. nodeName.toLowerCase ()! == "object") {var i = g.call (b, c); if (! i | | a | | && b.document b.document.nodeType == 11) return i} catch (j) {} return b, c, d, e, f, g, h = this; if (! un typeof = "cadena") return g}, cuenta con: function (a) {var b, c = p (a, este), d c.length =; this.filter retorno (function () {for (b = 0, b <d, b + +) si (p.contains (esto, c [b])) return 0})}, no: la función (¡a) {this.pushStack retorno (bj (esto, a, 1), "no", a)}, filtro: function (a) {this.pushStack return (! bj (esto, a, 0), "filtro", a)}, es: function (a) {return a && (typeof! c, d = 0, e = this.length, f = [], g = bf.test (a) | | typeof ? f = f.length> 1 p.unique (f): f, this.pushStack (f, "más cercano", a)}, índice: function (a) {return un typeof? c = a == typeof "cadena" p (a, b): p.makeArray (a && a.nodeType [a]: a?), d = p.merge (this.get (), c); devolver esto?. pushStack (bh (c [0]) | | bh (d [0]) d:? p.unique (d))}, addBack: function (a) {return b = a.parentNode; volver && b == b.nodeType 11 b: null}, los padres: function (a) {return p.dir (a, "parentNode")}, parentsUntil: function (a, b, c)? {return p.dir (a, "parentNode", c)}, al lado: function (a) {return bi (a, "nextSibling")}, prev: function (a) {return bi (a, "previousSibling") }, nextAll: function (a) {return p.dir (a, "nextSibling")}, prevAll: function (a) {return p.dir (a, "previousSibling")}, nextUntil: función (a, b, c) {return p.dir (a, "nextSibling", c)}, prevUntil: función (a, b, c) {p.dir retorno (a, "previousSibling", c)}, hermanos: función (a) {return p.sibling ((a.parentNode | | {}) firstChild, a.)}, los niños: function (a) {p.sibling retorno (a.firstChild)}, contenido: function (a) {return e = p.map (este, b, c); bc.test retorno (A) | | (d = c), d && typeof e}, hermano: función (a, b) {var c = []; for (; una; a = a.nextSibling) a.nodeType === 1 && a == b && c.push (a); retorno c}}! ); var p.access (esta función, (a) {return this.each (function (b) {. p (este) wrapAll (a.call (esto, b))}), si (esto [0]) {var a = este, mientras que (&& a.firstChild a.firstChild.nodeType === 1) un a.firstChild =; volver a}) append (this)}} devolver este, wrapInner:. función () {p.isFunction retorno ( ? a) this.each (function (b) {. p (este) wrapInner (a.call (esto, b))}): this.each (function () {var b = p (este), c = b contenidos. (); c.length c.wrapAll (a):? b.append (a)})}, envoltura: function (a) {var b = p.isFunction (a); t retorno extend ({texto: function (a) {p.access retorno (this, function (a) {return this.each (function (b) {. p (este) wrapAll (a.call (esto, b))}), si (esto [0]) {var a = este, mientras que (&& a.firstChild a.firstChild.nodeType === 1) un a.firstChild =; volver a}) append (this)}} devolver este, wrapInner:. función () {p.isFunction retorno ( ? a) this.each (function (b) {. p (este) wrapInner (a.call (esto, b))}): this.each (function () {var b = p (este), c = b contenidos. (); c.length c.wrapAll (a):? b.append (a)})}, envoltura: function (a) {var b = p.isFunction (a); t retorno extend ({texto: function (a) {p.access retorno (this, function (a) {return this.each (function (b) {. p (este) wrapAll (a.call (esto, b))}), si (esto [0]) {var a = este, mientras que (&& a.firstChild a.firstChild.nodeType === 1) un a.firstChild =; volver a}) append (this)}} devolver este, wrapInner:. función () {p.isFunction retorno ( ? a) this.each (function (b) {. p (este) wrapInner (a.call (esto, b))}): this.each (function () {var b = p (este), c = b contenidos. (); c.length c.wrapAll (a):? b.append (a)})}, envoltura: function (a) {var b = p.isFunction (a); t retornohis.each (function (c) {p (este) wrapAll (b a.call (esto, c):.? a)})}, unwrap: function () {return un p.clean = (argumentos); this.pushStack retorno (p.merge (a, este), "antes", this.selector)}}, después: function () {if (bh (este) [0] ) return un p.clean = (argumentos); this.pushStack retorno (p.merge (esto, a), "después de", this.selector)}}, remover: function (a, b) {var esto}, vacío: function () {var esto}, clon: function (a, b) {return a = a == null 1:! a, b = b == null a: b, this.map (function () {return p.clone (esto , a, b)})}, html: function (a) {p.access retorno (this, function (a) {var c = presente [0] | | {}, d = 0, e = this.length; ? si (a === b) la devolución c.nodeType === 1 c.innerHTML.replace (ma, ""): b; if (typeof c = p (este), d = c.html (); c.replaceWith (a.call (esto, b, d))}): (typeof = "una cadena" && (a = p (a)!. detach ()), this.each (function () {var this.remove (a, 0!)}, domManip: función (a, c, d) {a = [] concat.apply ([], a); var e, f, g, h, i = 0,. j = a [0], k = [], l = this.length, si this.each retorno (function () {(&& p.support.checkClone l> 1 && j == typeof "cadena" && bw.test (j)!) . p (este) domManip (a, c, d)}), si (p.isFunction (j)) return this.each (function (e) {var esta}}), p.buildFragment = función (a, c, d) {var f, g, h, i = a [0];! retorno c = c | | E, C = c.nodeType && c [0] | | c, c = c.ownerDocument | | c, a.length === 1 && typeof g [b] (esto [0]), esto, porque. (; e <h;e++)d=(e> this.clone 0 (0):?! esto) get (), p (g [e] ) [b] (d), f = f.concat (d); this.pushStack retorno (f, a g.selector,)}}), p.extend ({clon: función (a, b, c) { var d = e = null, g}, limpio: función (a, b, c, d) {var f, g, h, i, j, k, l, m, n, o, q, r, s = b e && === bA, t = []; si | b = e (b | typeof b.createDocumentFragment == "undefined"!), porque (¡f = 0; (h = a [f]) ​​= null; f + +) {== typeof h "número" && (h + = ""); (! h) en caso de continuar; if (typeof t}, cleanData: función (a, b) {var en c.events) k [f] p.event.remove (e, f):? p.removeEvent (e, f, c.handle); i [d] && (borrar i [d], j eliminar e ¿[h]: e.removeAttribute e.removeAttribute (h): e [h] = null, p.deletedIds.push (d))}}}}), function () {var a, b; p.uaMatch = función (a) {a = a.toLowerCase (); var = b / (cromo) [\ /] ([\ w.] +) / exec (a) | | / (WebKit) [\ /] ([. \ w] +) / exec (a) | | / (ópera) (:..?... * Versión |) [\ /] ([\ w] +) / exec (a) | | / (MSIE) ([\ w.] +) / exec (a) | | a.indexOf ("compatible") <0 && / (mozilla) (:. *.?? a (b, c) {return new c (c, d) {return d && d instanceof && p! (d instanceof a) && (d = a (d)), p.fn.init.call (esto, c, d, b)}, a.fn.init . prototipo = a.fn; var b = a (e); volver a}} (); var RegExp ("^ (" + q + ") (. *) $", "I"), BQ = new RegExp ("^ (" + q + ") (?! Px) [% az] + $", "i "), bR = new p.access (esta función, (a, c, d) {return d == b p.style (a, c, d):? p.css (a, c)}, a, c, arguments.length > 1)}, show: function () {return b $ (this, 0)}, ocultar: function () {return b $ (this)}, toggle: function (a, b) {var c = typeof un == "boolean", retorno c = Bh (a, "opacidad"); retorno h && "get" en && h (f = h.get (a, 1, e)!) == b f:? j [c]; g = typeof h) | | (d = h.set (a, d, e)) == b) try {j [c] = d} catch (k) {}}, css: función (a, c, d,! e) {var f, g, h, i = p.camelCase (c); c = retorno p.cssProps [i] | | (p.cssProps [i] = por (a.style, i)), h = p.cssHooks [c] | | p.cssHooks [i], && h "get" en && h (! h.get f = (a, 0, e)), f === b && (f = BH (a, c )), f === "normales" && c en Bu && (f = bU [c]), d | | e == b (g = parseFloat (f), d |? |? p.isNumeric (g) g | | 0: f): f}, canje: function (a, b, c) {var d, e, f = {}; para (e en b) f [e] = a.style [e], una . estilo [e] = b [e]; d = c.call (a), porque (e en b) a.style [e] = f [e];? devolver d}}), a.getComputedStyle BH = función (b, c) {var d, e, f, g, h = a.getComputedStyle (b, null), i = b.style, retorno c, d, e = a.currentStyle && a.currentStyle [b], f = a.style; retorno a.offsetWidth === 0 && bN.test (BH (a, "display")) p.swap (a, bt, function () {return cb (a, b, d)}): cb (a, b, d)}, set: function (a, c, d) {return "+ E}}), p (function () {p.support.reliableMarginRight | | (p.cssHooks.marginRight = {get: function (a, b) {return p.swap (a, {display:" inline- bloque "}, function () {if (b) la devolución d = bh (a, b); retorno d, e = c == typeof "string" c.split (""): [c], f = {}; para (d = 0, d <4, d + +) f [a + BV [d] +? b] = E [d] | | e [d-2] | | e [0];}} f retorno, bO.test (a) | | (. p.cssHooks [a + b] set = b_)} ); var p.param (this.serializeArray ())}, serializeArray: function () {this.map retorno (function () {this.elements retorno p.makeArray (this.elements): este}). filtro (function () {return c = p (este) val ();. retorno Para (d en a) ci (d, a [d], c, f),. retorno e.join ("&") reemplazar (cd, "+")}; var cj, ck, cl = / #. * $ /, cm = / ^ (*.?): [ ¡una cadena = "" && Cu) retorno cu.apply (esto, argumentos); if (this.length) devolver este; var e, f, g, h = este, i = a.indexOf (""); retorno i> = 0 && (E = a.slice (i, a.length), un a.slice = (0, i)), p.isFunction (c) (d = c, c = b): c && typeof ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend ". split (" "), la función (a, b) {P.Fn [b] = function (a) {this.on retorno (b, a)}}), p.each ([ "get", "post"], function (a, c) {p [c] = function (a, d, e, f) {return p.get (a, b, c, "script")}, getJSON: función (a, b, c) {return p.get (a, b, c, "json")}, ajaxSetup: función (a, b) {return charset = UTF-8 ", processData: 0, async: 0, acepta: {xml:" application / xml, text / xml ", html:" text / html ", text:" text / plain ", json: "application / json, text ": a.String," texto html ": 0," texto json ": p.parseJSON," texto y (a, c, f, i) {var a == "objeto" && (c = a, a = b), c = c | | {}; var d, e, f, g, h, i, j, k, l = p.ajaxSetup ({} , c), m = l.context | | l, n = m == && l (m.nodeType | | m instanceof p) p (m):? p.event, o = p.Deferred (), q = p.Callbacks ("una vez c = a.toLowerCase (); a = u [c] = u [c] | | a, t [A] = b}}, regresar este getAllResponseHeaders:? function () {return v === 2 e: null }, getResponseHeader: function (a) {var c; if (v === 2) {if {f = {}; while (c = cm.exec (e)) f [c [1] (f!). toLowerCase ()] = c [2]} c = f [a.toLowerCase ()]} return c === b null: c}, overrideMimeType: función () {return v | | (l.mimeType = a ), esto}, abortar: function (a) {return b; si (v <2) para (b en a) r [b] = [r [b], a [b]]; más b = a [x.status], x.always (b)} return l.data = "cadena" && (l.data = p.param (l.data, l.traditional)), Ca (cv, l, c, x); if (v === 2) retorno l.data), d = l.url; if (l.cache === 1) {var "+ Cx +"; q = 0,01 ":" "): l.accepts [" * "]); para (k en en {éxito: 1, error: 1, completo: 1}!) x [k] (l [k]); g = cA (cw, l, c, x), si (g) y (-1, " no tirar B}}} return return x x.abort ()}, activa: 0, lastModified: {}, etag: {}}); var a = cE.pop () | | p.expando + "_" + cH + +;! devolver este [a] = 0, a}}), p.ajaxPrefilter ("json jsonp", function (c, d, e) { var f, g, h, i = c.data, j = c.url, k = c.jsonp!! == 1, l = k && cG.test (j), M = K &&! l && typeof json "] = function () {return h | | p.error (f +" no fue application / javascript, application / ECMAScript, application / x-ECMAScript "}, contenido: {script de javascript :/ | ECMAScript /}, convertidores: {" script text ": function (a) {return Ci, Cj = a.ActiveXObject? function () {for (var a en d; retorno {enviar: function (e, f) {var en en e) i.setRequestHeader (h, e [h])} catch (j) {} i.send (&& c.hasContent c.data | | null), d = function (a, e) {var h, j, k , l, m; try {if (d && (E | | i.readyState === 4)) {d = b, g (&& i.onreadystatechange p.noop =, && CJ borrar cN, CO, CP = / ^ (: alternar | mostrar | ocultar?) $ /, CQ = new RegExp ("^ (: ([- +]) = |) (" + q + ") ([% az] *) $ "," i "), CR = / queueHooks $ /, cs = [CY], cT = {" * ": [función (a, b) {var f}]}; p.Animation = p.extend (CW, {tweener: función (a, b) {p.isFunction (a) (b = a, a = ["*"]): a = a?. split (""); var ? a = cZ.propHooks [this.prop]; devuelven un a.get && a.get (este): cZ.propHooks._default.get (this)}, ejecute: function (a) {var b, c = cZ.propHooks [this.prop]; volver b; volver c = P.Fn [b]; P.Fn [b] = function (d, e, f) {return d == null | | typeof e = p.isEmptyObject (a), f = p.speed (b, c, d), g = function () {var b = CW (esto, p.extend ({}, a), f); && e b. stop}, retorno e | | f.queue === 1 this.each (g): this.queue (f.queue, g)}, parada: function (a, c, d) {(0!)? var e = function (a) {var b = a.stop; delete a.stop, b (d)};! un retorno typeof = "cadena" && (d = c, c = a, a = b), c && una !! == 1 && this.queue (a | | "fx", []), this.each (function () {var b = 0, c = a = && nulos a + "queueHooks", f, g = p.timers! = p._data (this); if (c) g [c] && g [c] stop && e (g [c]);. cosa para (c en this.animate (B, A, C, D)}}), p.speed = function (a, b, c) {var d = a && typeof d.duration == "número" d.duration: d.duration en p.grep (p.timers, function (b) {return un b.elem ===}) Longitud}); c_ var = / ^ (:.? body | html) $ / i; p.fn.offset = función () {if (arguments.length) vuelven a === b este: this.each (function (b) {p.offset.setOffset (esto, a, b)}); var b = a.offsetTop, c = a.offsetLeft, retorno d = p.css (a, "posición"); d === "estáticos" && (a.style.position = "relativa"); var b b.using.call (a, j): e.css (j)}}, p.fn.extend ({position: function () {if (esto [0]) return; var?! this.map (function () {var a | | e.body})}}), p.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, la función (a, c) {var d = / Y / .test (c); p fn. [a] = function (e) {p.access retorno (this, function (a, e, f) {var g = da (a); if (f === b) la devolución g en c g = && arguments.length (d | | typeof e = "booleano"!), h = d | | (e === 0 | | f === 0 "margen":? "frontera"), p regreso . acceso (esta función, (c, d, e) {var f; retorno definir == "función" && define.amd && && define.amd.jQuery define ("jquery", [], function () {return p})}) (ventana);